20250908에서는 dictionary 내부의 value들을 조회하는 정도에 그쳤지만 금일 수업에서는 필요한 value들을 다양한 방법을 (key를 일일이 지정해서 넘어가거나 / 반복문을 작성하거나)
통해 추출한 후에 이를 연산하는 것까지 처리하고 있다.
이상의 코드는 그 예시이고, 앞으로는 데이터를 다루는 부분에 있어서 매우 중요하다.
SQL에서도 각각 컬럼에 있는 값들을 필요한 것들을 추출해서 연산한 후에 집게함수를 사용하는 등의 응용이 있을 수 있으니 python으로 작성하는 법 뿐만 아니라
원리 자체를 학습하는 편이 좋다.
```python
for resource in resources:
    resources[resource] -= MENU['라떼']['재료'][resource]
    if resource == '커피':
        print(f'{resource}:{resources[resource]}g')
    if resource == '물':
        print(f'{resource}:{resources[resource]}ml')
    if resource == '우유':
        print(f'{resource}:{resources[resource]}ml')
```

# coffee_machine_oop_version 관련 수업
```python
class MenuItem:
    """각 메뉴 아이템들을 모델링합니다."""
    def __init__(self, name, water, milk, coffee, cost):
        self.name = name
        self.cost = cost
        self.ingredients = {
            "water": water,
            "milk": milk,
            "coffee": coffee,
        }
class Menu:
    """음료 메뉴를 모델링합니다."""
    def __init__(self):
        self.menu = [
            MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5), 
            MenuItem(name="espresso", water=50, milk=0, coffee=18, cost=1.5),
            MenuItem(name="cappuccino", water=250, milk=50, coffee=24, cost=3),
            # MenuItem(name="카라멜마키아토", water=200, milk=60, coffee=26, cost=4),
        ]

    def get_items(self):
        """이용 가능한 모든 메뉴 아이템의 이름을 반환합니다."""
        options = ""
        for item in self.menu:
            options += f"{item.name}/"
        return options

    def find_drink(self, order_name):
        """특정 음료를 이름으로 메뉴에서 검색합니다. 해당 아이템이 존재하면 반환하고, 그렇지 않으면 None을 반환합니다."""
        for item in self.menu:
            if item.name == order_name:
                return item
        print("죄송합니다. 해당 아이템은 이용할 수 없습니다.")
```

이상의 코드에서 python 상에서 잘 보지 못했던 부분들을 검증한다.
```python
class MenuItem:
    """각 메뉴 아이템들을 모델링합니다."""
    def __init__(self, name, water, milk, coffee, cost):
        self.name = name
        self.cost = cost
        self.ingredients = {
            "water": water,
            "milk": milk,
            "coffee": coffee,
        }
```
class MenuItem의 경우 객체를 생성할 때, 이름 , 물 , 우유 , 커피 , 가격을 매개변수로 받는다.
그런데 여태까지의 경우
```python
class MenuItem:
 def __init__(self, name, water, milk, coffee, cost):
        self.name = name
        self.water = water
        self.milk = milk
        self.coffee = coffee
        self.cost = cost
```
의 형태로 썼던 것과 달리 water / milk / coffee 매개변수들은 전부 ingredient라는 매개변수에 속하지 않은 속성(인스턴스 변수)의 dictionary value 값으로 저장되어 있다는 점이다. 앞으로 Java / Springboot / Python 상에서 객체의 field / instance variable들이 매개변수 생성자의 argument들과 반드시 일치하지 않는 경우도 나오게 된다.
```python
class Menu:
    """음료 메뉴를 모델링합니다."""
    def __init__(self):
        self.menu = [
            MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5), 
            MenuItem(name="espresso", water=50, milk=0, coffee=18, cost=1.5),
            MenuItem(name="cappuccino", water=250, milk=50, coffee=24, cost=3),
            # MenuItem(name="카라멜마키아토", water=200, milk=60, coffee=26, cost=4),
        ]
```
이상의 코드에서 Menu 객체를 생성한다고 가정한다.
```python
menu = Menu()
```
라고 생성해야 한다. 이유는 82번 라인 을 확인하면 된다. > 생성자가 call1() 유형이기 때문
그렇다면 menu라고 하는 객체를 생성했을 때 , menu.menu라는 인스턴스 변수가 있따는 것을 확인할 수 있다.
그리고 그 인스턴스 변수의 자료형은 list가 될 것이고, 내부 element의 자료형은 MenuItem의 객체라고 볼 수 있다.
또한 MenuItem 객체를 생성할 때 반드시 name / water / milk / coffee / cost 를 요구했기 때문에
`MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5),`
와 같은 방식으로 작성되었다.
즉 menuItem = MenuItem(name="latee",water=200, milk = 150 , coffee =24 , cost=2.5)라고 생각하면 이해하기 편하다.

매개변수 생성자를 호출하여 name / water / milk / coffee / cost를 keyword argument를 통해서 값을 집어넣었고, 이를 menu.menu의 0번지, 1번지, 2번지에 넣는 방식으로 이루어졌다고 하면
```java
public class Main {
    main{
        Student[] students = new Student(new MiddelSchool(),new HighSchool());
        }
}
```
처럼 Java에서 객체 생성할 때 내부 element로 new 생성자(); 형태로 객체의 이름이 없는 객체들을 만들어서 collections의 element로 써먹은 적이 있다.

동일한 예시라고 볼 수 있다.
```python
def process_coins():
    sum = 0
    # 이 부분에 로직이 작성되어야 한다.
    sum += float(input('쿼터 동전을 몇 개나 넣으시겠습니까? >>> ')) *0.25
    sum += float(input('다임 동전을 몇 개나 넣으시겠습니까? >>> ')) *0.1
    sum += float(input('니켈 동전을 몇 개나 넣으시겠습니까? >>> ')) *0.05
    sum += float(input('페니  동전을 몇 개나 넣으시겠습니까? >>> ')) *0.01
    return sum

def is_transaction_successful(money_received, drink_cost):
    change = money_received - drink_cost
    if change >= 0:

        global profit
        profit += drink_cost
        print(f'잔돈 ${change}를 반환합니다.')
        return True
    else:
        print(f"금액이 충분하지 않습니다. ${money_received}를 반환합니다.")
        return False
```
```python
    def process_coins(self):
        """투입된 동전으로부터 계산된 총액을 반환합니다."""
        print("동전을 투입해주세요.")
        for coin in self.COIN_VALUES:
            self.money_received += int(input(f"{coin}는 몇 개입니까?: ")) * self.COIN_VALUES[coin]
        return self.money_received

    def make_payment(self, cost):
        """지불이 성공했을 때 True를 반환하고, 돈이 부족하면 False를 반환합니다."""
        self.process_coins() # 내부에서 외부 메서드를 호출
        if self.money_received >= cost:
            change = round(self.money_received - cost, 2)
            print(f"여기 잔돈 {self.CURRENCY}{change}를 반환합니다.")
            self.profit += cost
            self.money_received = 0
            return True
        else:
            print("죄송합니다. 돈이 충분하지 않습니다. 돈을 반환합니다.")
            self.money_received = 0
            return False
```
이상의 코드는 pop version의 process_coins() / is_transaction_successful()과 oop version의 process_coins()/make_payment()입니다.

주목해야 할 점은 make_payment() 내부에서 process_coins()를 호출한다는 점이다.
그 의미는 pop version의 main에서는 process_coins()를 호출하여 money-_received에 저장할 필요가 있었지만, oop version에서는 make_payment()만 호출하면 알아서 process_coins()의 결과값을 가지고 온다는 점이다.

그 결과로 is_transaction_successful()를 정의할 때에는 두 개의 매개변수가 필요했었다.(money_received, drink_cost).
하지만 make_payment()의 경우에는 내부 process_coins()를 호출하기 때문에 하나의 매개변수만 있으면 된다.(cost)




```python
'''
응용 예제
1. 다음 지시 사항을 읽고 이름과 전체 인구수를 저장할 수 있는 Person 클래스를 작성하시오.
지시 사항

1. 다음과 같은 방법으로 man과 woman 인스턴스를 생성하시오.
man = Person('김일')
woman = Person('김이')

2. man과 woman 인스턴스가 생성되면 다음과 같은 메세지를 출력할 수 있도록 작성하시오.
김일이(가) 태어났습니다.
김일이(가) 태어났습니다.

3. 다음 코드를 통해서 전체 인구수를 조회할 수 있도록 작성하시오.
print(f'전체 인구수 : {Person.get_population()}')

4. 다음과 같은 명령어로 man 인스턴스를 삭제하시오.
del man

5. man 인스턴스가 삭제되면 다음과 같은 메세지를 출력 할 수 있도록 소멸자를 정의하시오.
RIP 김일
'''
class Person:
    population = 0
    def __init__(self, name):
        self.name = name
        print(f'{name}이(가) 태어났습니다.')
        Person.population += 1
    @classmethod
    def get_population(cls):
        return cls.population
    def __del__(self):
        Person.population -= 1
        print(f'RIP {self.name}')



man = Person('김일')
woman = Person('김이')
print(f'전체 인구수 : {Person.get_population()}')
del man
print(f'현재 인구수 : {Person.get_population()}')
print('프로그램 종료')
```
이상의 코드에서 주목할 점  : 
- 특정 메서드가 인스턴스/클래스/정적 메서드 중에 무엇이 되어야 하는가.
  -  클래스 변수가 있더라도 인스턴스 변수가 포함된다면 인스턴스 메서드로 작성하는 편
    - 클래스 메서드는 특정 인스턴스를 불러낼 수 없다.
    - 반면에 인스턴스 메서드는 모든 인스턴스가 공유하는 클래스 변수를 클래스명.클래스변수명 으로 호출할 수 있다.
- 이상의 내용에서 생각해보자면 소멸자의 정의는 '객체의 소멸을 정의하는 메서드'이기 때문에 특정 객체에 가해지는 작용이라고 볼 수 있고, 또한 RIP 김일' 이라는 점에서 객체명.name이라는 인스턴스 변수를 참조해야만 하기 때문에 population -= 1을 쓰더라도 인스턴스 메서드로 정의하는 것이 적합하다.
